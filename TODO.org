* New pack file format
** an archiver/compressor
** support strong encryption
** avoid mistakes of legacy formats
* Features
** published both as a library and an executable binary
** follows symlinks or not, depending on options
** preserves ownership and permissions, or not to conserve space
** saves all available directory and file metadata
** strong encryption using a password and random salt
** extensible format for archive and entry headers
** encrypted packs cannot have their contents listed
** should be efficient for small chunks of data
** each file may be optionally compressed
** handle any number of files of any size
** support different hash digests for data verification
** support different key derivation functions
** support different encryption algorithms
** support different compression algorithms
* Format
** Considerations
*** future-proof, extensible format supporting optional fields of various lengths
*** records various metadata about files and directories if available from OS
*** records whether file data is Big Endian or Little Endian
*** fields are always network byte order (Big Endian)
*** may include data checksums for verification
*** textual data is UTF-8 encoded
*** XML is flexible, supports complex data types
*** JSON is smaller than XML, easy to parse
*** EXIF style is very compact (rows of tuples consisting of tag, size, value)
** Encrytion
*** password is used to derive a key using one of various algorithms, typically with a salt
*** derived key (aka secret) is used to perform symmetric-key encryption on the file data
*** directory/file header data rows are encrypted to prevent listing of archive contents
** Archive header
*** header size limited to 64 KB
*** EXIF style entries after the initial version-specific rows
| Offset | Size | Purpose                        |
|--------+------+--------------------------------|
|      0 |    4 | File signature ('EXAF')        |
|      4 |    2 | format version (major/minor)   |
|      6 |    2 | remaining header size in bytes |
|      8 |    2 | optional field tag             |
|     10 |    2 | optional field size in bytes   |
|     12 |    n | optional field value           |
|    ... |  ... | ...                            |
*** optional fields
| Name    | Purpose                                   | Tag  |
|---------+-------------------------------------------+------|
| keyalgo | key derivation algorithm (i.e. Argon2id)  | 'KD' |
| salt    | random salt for encrypting password       | 'SA' |
| iter    | number of iterations depending on KDF     | 'IT' |
| encalgo | encryption algorithm (AES, Blowfish, etc) | 'EA' |
*** more optional fields can be added over time
*** field values will never be longer than 64 KB
| Name  | Size | Purpose                       |
|-------+------+-------------------------------|
| Tag   |    2 | uniquely identifies the field |
| Size  |    2 | length of the field value     |
| Value |    N | field value                   |
** Archive entry considerations
*** will need to ensure that any extended attributes are less than 64 KB
*** directory entries are optional, but must appear before files that refer to them
*** duplicate directory entries are allowed for easier addition of files
** Archive entry structure
*** all file paths and names are UTF-8 encoded
*** entry header will never be longer than 64 KB
*** entry date/time is ~Unix time~ (seconds since the epoch) as 32 or 64 bits
**** https://en.wikipedia.org/wiki/Unix_time
**** length of the field will be either 4 (32 bits) or 8 (64 bits)
*** integer values will be serialized to the smallest number of bytes necessary
**** e.g. values below 256 will be written as 1 byte
*** each entry consists of two or three blocks of data
| Name         | Size | Purpose                              |
|--------------+------+--------------------------------------|
| Header size  | 2    | length of the header in bytes        |
| Header value | N    | header table rows as described below |
| File data    | M    | files only: compressed data          |
*** header rows consist of 2 + 2 + N bytes (tag, size, value)
*** entry with row tag of =ID= is a directory while one with =DI= is a file
*** field values will never be longer than 64 KB
| Name  | Size | Purpose                       |
|-------+------+-------------------------------|
| Tag   |    2 | uniquely identifies the field |
| Size  |    2 | length of the field value     |
| Value |    N | field value                   |
** Archive entry representing a directory
*** codifies each unique path as a numeric value for efficiency
*** fields
| Name  | Purpose                             | Required? | Tag  | Size   |
|-------+-------------------------------------+-----------+------+--------|
| id    | Unique identifier                   | yes       | 'ID' | 4      |
| path  | path value as UTF-8                 | yes       | 'PA' | vary   |
| mode  | Unix mode                           |           | 'MO' | 2      |
| attrs | Windows file attributes             |           | 'FA' | 4      |
| mtime | modification date/time as Unix time |           | 'MT' | 4 or 8 |
| ctime | creation date/time as Unix time     |           | 'CT' | 4 or 8 |
| atime | access date/time as Unix time       |           | 'AT' | 4 or 8 |
| xattr | Extended file system attributes     |           | 'XA' | vary   |
| user  | name of FS owner                    |           | 'UN' | vary   |
| uid   | user identifier                     |           | 'UI' | 32     |
| group | name of FS group                    |           | 'GN' | vary   |
| gid   | group identifier                    |           | 'GI' | 32     |
*** example entry
| Tag  | Size | Value                        |
|------+------+------------------------------|
| 'MO' |    2 | 0o40755                      |
| 'ID' |    4 | 16344                        |
| 'PA' |   28 | node_modules/saml2-js/lib-js |
| 'MT' |    4 | 0x6604C3BF                   |
| 'UN' |    8 | nfiedler                     |
| 'UI' |    2 | 501                          |
| 'GN' |    5 | staff                        |
| 'GI' |    2 | 20                           |
** Archive entry representing a file
*** fields
| Name     | Purpose                             | Required? | Tag  | Size    |
|----------+-------------------------------------+-----------+------+---------|
| name     | name of file or directory           | yes       | 'NM' | vary    |
| origlen  | byte size of original data          | yes       | 'SZ' | 1,2,4,8 |
| mode     | Unix mode (assumed to be 16 bits)   |           | 'MO' | 2       |
| attrs    | Windows file attributes             |           | 'FA' | 4       |
| dirid    | directory identifier                |           | 'DI' | 4       |
| complen  | byte size of compressed data        |           | 'LN' | 1,2,4,8 |
| compalgo | compression algorithm               |           | 'CA' | 4       |
| hashalgo | hash digest algorithm               |           | 'HA' | 4       |
| checksum | hash digest of original data        |           | 'CS' | vary    |
| mtime    | modification date/time as Unix time |           | 'MT' | 4 or 8  |
| ctime    | creation date/time as Unix time     |           | 'CT' | 4 or 8  |
| atime    | access date/time as Unix time       |           | 'AT' | 4 or 8  |
| xattr    | Extended file system attributes     |           | 'XA' | vary    |
| user     | name of FS owner                    |           | 'UN' | vary    |
| uid      | user identifier                     |           | 'UI' | 2       |
| group    | name of FS group                    |           | 'GN' | vary    |
| gid      | group identifier                    |           | 'GI' | 2       |
*** example entry
| Tag  | Size |                                      Value |
|------+------+--------------------------------------------|
| 'NM' |   16 |                           take_snapshot.rs |
| 'SZ' |    8 |                                      45130 |
| 'MO' |    2 |                                   0o100644 |
| 'DI' |    4 |                                      16344 |
| 'LN' |    8 |                                       7205 |
| 'CA' |    4 |                                     'LZMA' |
| 'HA' |    4 |                                     'SHA1' |
| 'CS' |   20 | 0xf29e0d471f31aca38e263720cb84ef5c7708a141 |
| 'MT' |    4 |                                 0x6604C3BF |
| 'UN' |    8 |                                   nfiedler |
| 'UI' |    2 |                                        501 |
| 'GN' |    5 |                                      staff |
| 'GI' |    2 |                                         20 |
** Custom format versus CBOR
*** custom type header size for =LICENSE= example: 154 bytes (macos)
*** CBOR header size for =LICENSE= example: 147 bytes (macos)
*** CBOR serializer writes the byte vector as an array of individual bytes
**** neither =serde_cbor= nor =ciborium= writes =Vec<u8>= as a byte string
*** custom format example using =LICENSE=
#+begin_src
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 45 58 41 46 01 00 00 00 ┊ 00 9a 4e 4d 00 07 4c 49 │EXAF•⋄⋄⋄┊⋄×NM⋄•LI│
│00000010│ 43 45 4e 53 45 53 5a 00 ┊ 08 00 00 00 00 00 00 04 │CENSESZ⋄┊•⋄⋄⋄⋄⋄⋄•│
│00000020│ 39 4d 4f 00 02 81 a4 48 ┊ 41 00 04 53 48 41 31 43 │9MO⋄•××H┊A⋄•SHA1C│
│00000030│ 53 00 14 fa 67 91 85 a2 ┊ 49 ef e2 2d 77 49 21 af │S⋄•×g×××┊I××-wI!×│
│00000040│ 87 3a 01 ef 09 ce 01 4d ┊ 54 00 08 00 00 00 00 66 │×:•×_×•M┊T⋄•⋄⋄⋄⋄f│
│00000050│ 07 a4 1c 43 54 00 08 00 ┊ 00 00 00 66 07 a4 1c 41 │•×•CT⋄•⋄┊⋄⋄⋄f•×•A│
│00000060│ 54 00 08 00 00 00 00 66 ┊ 10 b8 2f 55 4e 00 08 6e │T⋄•⋄⋄⋄⋄f┊•×/UN⋄•n│
│00000070│ 66 69 65 64 6c 65 72 47 ┊ 4e 00 05 73 74 61 66 66 │fiedlerG┊N⋄•staff│
│00000080│ 55 49 00 04 00 00 01 f5 ┊ 47 49 00 04 00 00 00 14 │UI⋄•⋄⋄•×┊GI⋄•⋄⋄⋄•│
│00000090│ 43 41 00 04 7a 73 74 64 ┊ 4c 4e 00 08 00 00 00 00 │CA⋄•zstd┊LN⋄•⋄⋄⋄⋄│
│000000a0│ 00 00 02 ab             ┊                         │⋄⋄•×    ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
#+end_src
*** CBOR format example using =LICENSE= (checksum is not a major type 2, byte string)
#+begin_src
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 45 58 41 46 01 00 00 00 ┊ 00 93 bf 62 4e 4d 67 4c │EXAF•⋄⋄⋄┊⋄××bNMgL│
│00000010│ 49 43 45 4e 53 45 62 4d ┊ 4f 19 81 a4 62 46 41 f6 │ICENSEbM┊O•××bFA×│
│00000020│ 62 55 49 19 01 f5 62 55 ┊ 4e 68 6e 66 69 65 64 6c │bUI••×bU┊Nhnfiedl│
│00000030│ 65 72 62 47 49 14 62 47 ┊ 4e 65 73 74 61 66 66 62 │erbGI•bG┊Nestaffb│
│00000040│ 43 54 1a 66 07 a4 1c 62 ┊ 4d 54 1a 66 07 a4 1c 62 │CT•f•×•b┊MT•f•×•b│
│00000050│ 41 54 1a 66 10 b8 2f 62 ┊ 53 5a 19 04 39 62 4c 4e │AT•f•×/b┊SZ••9bLN│
│00000060│ 19 02 ab 62 43 41 64 7a ┊ 73 74 64 62 48 41 64 53 │••×bCAdz┊stdbHAdS│
│00000070│ 48 41 31 62 43 53 94 18 ┊ fa 18 67 18 91 18 85 18 │HA1bCS×•┊×•g•×•×•│
│00000080│ a2 18 49 18 ef 18 e2 18 ┊ 2d 18 77 18 49 18 21 18 │×•I•×•×•┊-•w•I•!•│
│00000090│ af 18 87 18 3a 01 18 ef ┊ 09 18 ce 01 ff          │×•×•:••×┊_•×•×   │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
#+end_src
** XAR-style table-of-contents vs tar-style header/data pairs
*** XAR seems hugely complex to both generate the TOC as well as add an additional file later
*** TAR style would mean recording file tree structure as separate records in-line with files
*** TAR style allows for very easy addition of new files, simply append new header/file pairs
* Action Plan
** Proof of Concept
*** write some code to get started, creating a =pack= and =unpack= binary
*** focus on making it work rather than a great design and unit tests
*** action plan
**** DONE pack a single file w/o compression
**** DONE add file metadata
**** DONE add checksum field
**** DONE add compression
**** DONE print the archive contents
**** TODO add directory entries to the archive
**** TODO recurse a directory
**** TODO add an additional file to an existing archive
**** DONE determine lower bound for compressing files
***** =xz= no good for anything less than ~300~ characters
***** =bzip2= no good for anything less than ~180~ characters
***** =gzip= no good for anything less than ~150~ characters
***** =zstd= no good for anything less than ~120~ characters
**** TODO do not compress files if less than ~256~ bytes
**** TODO extract one particular file from an archive
**** DONE test on Windows
**** TODO add encryption
** develop specification
*** determine the byte format and what makes the most sense
*** write the specification as a separate document
*** draw diagrams to help visualize the byte layout
*** provide guidance and examples for implementation
** test and benchmark
*** test with a real-life directory structure consisting only of zero-length files
**** idea is to measure overhead without any file content
*** use a snapshot of the Linux source tree, compare to Pack (see issue #4)
** additional features
*** list contents of an archive
*** record symbolic links
*** follow symbolic links
*** record extended attributes
*** file/directory exclusion patterns on archive
*** file/directory exclusion patterns on extract
*** recognize certain kinds of (lossy) files that would not compress well and do not compress them
**** nearly all common image formats would not compress well
*** "delete" files from an archive by making them disappear? zip does this
*** ignore absolute path prefix when extracting archives
** library
*** allow many of the dependencies to be optional (e.g. zstandard)
*** read optional archive header tags into a map
*** create a reader and writer like the =tar= crate
*** allow for additional tag types not already in the spec
* Questions
** should archive and entry headers be checksummed (md5 or sha1)?
** data recovery (a la error correction)? 7zip, zip lack this, RAR has it
** what about Windows directory/file ownership and permissions?
** what about deduplicating files on the way into the archive?
*** that would be much more complex for both compressing and decompressing
*** would need a way for the duplicate to refer back to an earlier entry
* Reference
** Compression algorithms for consideration
| Name  | Description              |
|-------+--------------------------|
| LZMA  | Improved version of LZ77 |
| LZMA2 | Improved version of LZMA |
| BZip2 | Standard BWT algorithm   |
| Copy  | No compression method    |
** Key derivation functions for consideration
*** from https://en.wikipedia.org/wiki/Key_derivation_function
: In 2013 a Password Hashing Competition was announced to choose a new,
: standard algorithm for password hashing. On 20 July 2015 the competition
: ended and Argon2 was announced as the final winner. Four other algorithms
: received special recognition: Catena, Lyra2, Makwa, and yescrypt. As of
: May 2023, OWASP recommends the following KDFs for password hashing, listed
: in order of priority:
- Argon2id
- scrypt if Argon2id is unavailable
- bcrypt for legacy systems
- PBKDF2 if FIPS-140 compliance is required
** Symmetric-key algorithms for consideration
- Twofish
- Serpent
- AES
- Camellia
- Salsa20
- ChaCha20
- Blowfish
- CAST5
- Kuznyechik
- RC4
- DES
- 3DES
- Skipjack
- Safer
- IDEA
* Alternatives
** Pack
*** https://github.com/PackOrganization/Pack
*** appears to compress files into an SQLite database file
** zip
*** flawed encryption
*** https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html
** tar
*** https://www.gnu.org/software/tar/manual/html_node/Standard.html
*** there is much overhead per entry
*** compression requires separate tool
** 7-zip
*** https://www.7-zip.org
*** encrypted files can still have their contents listed
*** does not store file permissions
** xar
*** https://en.wikipedia.org/wiki/Xar_(archiver)
*** not widely available
